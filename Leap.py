# This file was automatically generated by SWIG (http://www.swig.org).
# Version 2.0.9
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.



from sys import version_info
if version_info >= (2,6,0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_LeapPython', [dirname(__file__)])
        except ImportError:
            import _LeapPython
            return _LeapPython
        if fp is not None:
            try:
                _mod = imp.load_module('_LeapPython', fp, pathname, description)
            finally:
                fp.close()
            return _mod
    _LeapPython = swig_import_helper()
    del swig_import_helper
else:
    import _LeapPython
del version_info
try:
    _swig_property = property
except NameError:
    pass # Python < 2.2 doesn't have 'property'.
def _swig_setattr_nondynamic(self,class_type,name,value,static=1):
    if (name == "thisown"): return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name,None)
    if method: return method(self,value)
    if (not static):
        self.__dict__[name] = value
    else:
        raise AttributeError("You cannot add attributes to %s" % self)

def _swig_setattr(self,class_type,name,value):
    return _swig_setattr_nondynamic(self,class_type,name,value,0)

def _swig_getattr(self,class_type,name):
    if (name == "thisown"): return self.this.own()
    method = class_type.__swig_getmethods__.get(name,None)
    if method: return method(self)
    raise AttributeError(name)

def _swig_repr(self):
    try: strthis = "proxy of " + self.this.__repr__()
    except: strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)

try:
    _object = object
    _newclass = 1
except AttributeError:
    class _object : pass
    _newclass = 0


try:
    import weakref
    weakref_proxy = weakref.proxy
except:
    weakref_proxy = lambda x: x


class SwigPyIterator(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, SwigPyIterator, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, SwigPyIterator, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _LeapPython.delete_SwigPyIterator
    __del__ = lambda self : None;
    def value(self): return _LeapPython.SwigPyIterator_value(self)
    def incr(self, n=1): return _LeapPython.SwigPyIterator_incr(self, n)
    def decr(self, n=1): return _LeapPython.SwigPyIterator_decr(self, n)
    def distance(self, *args): return _LeapPython.SwigPyIterator_distance(self, *args)
    def equal(self, *args): return _LeapPython.SwigPyIterator_equal(self, *args)
    def copy(self): return _LeapPython.SwigPyIterator_copy(self)
    def next(self): return _LeapPython.SwigPyIterator_next(self)
    def __next__(self): return _LeapPython.SwigPyIterator___next__(self)
    def previous(self): return _LeapPython.SwigPyIterator_previous(self)
    def advance(self, *args): return _LeapPython.SwigPyIterator_advance(self, *args)
    def __eq__(self, *args): return _LeapPython.SwigPyIterator___eq__(self, *args)
    def __ne__(self, *args): return _LeapPython.SwigPyIterator___ne__(self, *args)
    def __iadd__(self, *args): return _LeapPython.SwigPyIterator___iadd__(self, *args)
    def __isub__(self, *args): return _LeapPython.SwigPyIterator___isub__(self, *args)
    def __add__(self, *args): return _LeapPython.SwigPyIterator___add__(self, *args)
    def __sub__(self, *args): return _LeapPython.SwigPyIterator___sub__(self, *args)
    def __iter__(self): return self
SwigPyIterator_swigregister = _LeapPython.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)

class BoolArray(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, BoolArray, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, BoolArray, name)
    __repr__ = _swig_repr
    def iterator(self): return _LeapPython.BoolArray_iterator(self)
    def __iter__(self): return self.iterator()
    def __nonzero__(self): return _LeapPython.BoolArray___nonzero__(self)
    def __bool__(self): return _LeapPython.BoolArray___bool__(self)
    def __len__(self): return _LeapPython.BoolArray___len__(self)
    def pop(self): return _LeapPython.BoolArray_pop(self)
    def __getslice__(self, *args): return _LeapPython.BoolArray___getslice__(self, *args)
    def __setslice__(self, *args): return _LeapPython.BoolArray___setslice__(self, *args)
    def __delslice__(self, *args): return _LeapPython.BoolArray___delslice__(self, *args)
    def __delitem__(self, *args): return _LeapPython.BoolArray___delitem__(self, *args)
    def __getitem__(self, *args): return _LeapPython.BoolArray___getitem__(self, *args)
    def __setitem__(self, *args): return _LeapPython.BoolArray___setitem__(self, *args)
    def append(self, *args): return _LeapPython.BoolArray_append(self, *args)
    def empty(self): return _LeapPython.BoolArray_empty(self)
    def size(self): return _LeapPython.BoolArray_size(self)
    def clear(self): return _LeapPython.BoolArray_clear(self)
    def swap(self, *args): return _LeapPython.BoolArray_swap(self, *args)
    def get_allocator(self): return _LeapPython.BoolArray_get_allocator(self)
    def begin(self): return _LeapPython.BoolArray_begin(self)
    def end(self): return _LeapPython.BoolArray_end(self)
    def rbegin(self): return _LeapPython.BoolArray_rbegin(self)
    def rend(self): return _LeapPython.BoolArray_rend(self)
    def pop_back(self): return _LeapPython.BoolArray_pop_back(self)
    def erase(self, *args): return _LeapPython.BoolArray_erase(self, *args)
    def __init__(self, *args): 
        this = _LeapPython.new_BoolArray(*args)
        try: self.this.append(this)
        except: self.this = this
    def push_back(self, *args): return _LeapPython.BoolArray_push_back(self, *args)
    def front(self): return _LeapPython.BoolArray_front(self)
    def back(self): return _LeapPython.BoolArray_back(self)
    def assign(self, *args): return _LeapPython.BoolArray_assign(self, *args)
    def resize(self, *args): return _LeapPython.BoolArray_resize(self, *args)
    def insert(self, *args): return _LeapPython.BoolArray_insert(self, *args)
    def reserve(self, *args): return _LeapPython.BoolArray_reserve(self, *args)
    def capacity(self): return _LeapPython.BoolArray_capacity(self)
    __swig_destroy__ = _LeapPython.delete_BoolArray
    __del__ = lambda self : None;
BoolArray_swigregister = _LeapPython.BoolArray_swigregister
BoolArray_swigregister(BoolArray)

class Int32Array(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Int32Array, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Int32Array, name)
    __repr__ = _swig_repr
    def iterator(self): return _LeapPython.Int32Array_iterator(self)
    def __iter__(self): return self.iterator()
    def __nonzero__(self): return _LeapPython.Int32Array___nonzero__(self)
    def __bool__(self): return _LeapPython.Int32Array___bool__(self)
    def __len__(self): return _LeapPython.Int32Array___len__(self)
    def pop(self): return _LeapPython.Int32Array_pop(self)
    def __getslice__(self, *args): return _LeapPython.Int32Array___getslice__(self, *args)
    def __setslice__(self, *args): return _LeapPython.Int32Array___setslice__(self, *args)
    def __delslice__(self, *args): return _LeapPython.Int32Array___delslice__(self, *args)
    def __delitem__(self, *args): return _LeapPython.Int32Array___delitem__(self, *args)
    def __getitem__(self, *args): return _LeapPython.Int32Array___getitem__(self, *args)
    def __setitem__(self, *args): return _LeapPython.Int32Array___setitem__(self, *args)
    def append(self, *args): return _LeapPython.Int32Array_append(self, *args)
    def empty(self): return _LeapPython.Int32Array_empty(self)
    def size(self): return _LeapPython.Int32Array_size(self)
    def clear(self): return _LeapPython.Int32Array_clear(self)
    def swap(self, *args): return _LeapPython.Int32Array_swap(self, *args)
    def get_allocator(self): return _LeapPython.Int32Array_get_allocator(self)
    def begin(self): return _LeapPython.Int32Array_begin(self)
    def end(self): return _LeapPython.Int32Array_end(self)
    def rbegin(self): return _LeapPython.Int32Array_rbegin(self)
    def rend(self): return _LeapPython.Int32Array_rend(self)
    def pop_back(self): return _LeapPython.Int32Array_pop_back(self)
    def erase(self, *args): return _LeapPython.Int32Array_erase(self, *args)
    def __init__(self, *args): 
        this = _LeapPython.new_Int32Array(*args)
        try: self.this.append(this)
        except: self.this = this
    def push_back(self, *args): return _LeapPython.Int32Array_push_back(self, *args)
    def front(self): return _LeapPython.Int32Array_front(self)
    def back(self): return _LeapPython.Int32Array_back(self)
    def assign(self, *args): return _LeapPython.Int32Array_assign(self, *args)
    def resize(self, *args): return _LeapPython.Int32Array_resize(self, *args)
    def insert(self, *args): return _LeapPython.Int32Array_insert(self, *args)
    def reserve(self, *args): return _LeapPython.Int32Array_reserve(self, *args)
    def capacity(self): return _LeapPython.Int32Array_capacity(self)
    __swig_destroy__ = _LeapPython.delete_Int32Array
    __del__ = lambda self : None;
Int32Array_swigregister = _LeapPython.Int32Array_swigregister
Int32Array_swigregister(Int32Array)

class UInt32Array(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, UInt32Array, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, UInt32Array, name)
    __repr__ = _swig_repr
    def iterator(self): return _LeapPython.UInt32Array_iterator(self)
    def __iter__(self): return self.iterator()
    def __nonzero__(self): return _LeapPython.UInt32Array___nonzero__(self)
    def __bool__(self): return _LeapPython.UInt32Array___bool__(self)
    def __len__(self): return _LeapPython.UInt32Array___len__(self)
    def pop(self): return _LeapPython.UInt32Array_pop(self)
    def __getslice__(self, *args): return _LeapPython.UInt32Array___getslice__(self, *args)
    def __setslice__(self, *args): return _LeapPython.UInt32Array___setslice__(self, *args)
    def __delslice__(self, *args): return _LeapPython.UInt32Array___delslice__(self, *args)
    def __delitem__(self, *args): return _LeapPython.UInt32Array___delitem__(self, *args)
    def __getitem__(self, *args): return _LeapPython.UInt32Array___getitem__(self, *args)
    def __setitem__(self, *args): return _LeapPython.UInt32Array___setitem__(self, *args)
    def append(self, *args): return _LeapPython.UInt32Array_append(self, *args)
    def empty(self): return _LeapPython.UInt32Array_empty(self)
    def size(self): return _LeapPython.UInt32Array_size(self)
    def clear(self): return _LeapPython.UInt32Array_clear(self)
    def swap(self, *args): return _LeapPython.UInt32Array_swap(self, *args)
    def get_allocator(self): return _LeapPython.UInt32Array_get_allocator(self)
    def begin(self): return _LeapPython.UInt32Array_begin(self)
    def end(self): return _LeapPython.UInt32Array_end(self)
    def rbegin(self): return _LeapPython.UInt32Array_rbegin(self)
    def rend(self): return _LeapPython.UInt32Array_rend(self)
    def pop_back(self): return _LeapPython.UInt32Array_pop_back(self)
    def erase(self, *args): return _LeapPython.UInt32Array_erase(self, *args)
    def __init__(self, *args): 
        this = _LeapPython.new_UInt32Array(*args)
        try: self.this.append(this)
        except: self.this = this
    def push_back(self, *args): return _LeapPython.UInt32Array_push_back(self, *args)
    def front(self): return _LeapPython.UInt32Array_front(self)
    def back(self): return _LeapPython.UInt32Array_back(self)
    def assign(self, *args): return _LeapPython.UInt32Array_assign(self, *args)
    def resize(self, *args): return _LeapPython.UInt32Array_resize(self, *args)
    def insert(self, *args): return _LeapPython.UInt32Array_insert(self, *args)
    def reserve(self, *args): return _LeapPython.UInt32Array_reserve(self, *args)
    def capacity(self): return _LeapPython.UInt32Array_capacity(self)
    __swig_destroy__ = _LeapPython.delete_UInt32Array
    __del__ = lambda self : None;
UInt32Array_swigregister = _LeapPython.UInt32Array_swigregister
UInt32Array_swigregister(UInt32Array)

class FloatArray(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, FloatArray, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, FloatArray, name)
    __repr__ = _swig_repr
    def iterator(self): return _LeapPython.FloatArray_iterator(self)
    def __iter__(self): return self.iterator()
    def __nonzero__(self): return _LeapPython.FloatArray___nonzero__(self)
    def __bool__(self): return _LeapPython.FloatArray___bool__(self)
    def __len__(self): return _LeapPython.FloatArray___len__(self)
    def pop(self): return _LeapPython.FloatArray_pop(self)
    def __getslice__(self, *args): return _LeapPython.FloatArray___getslice__(self, *args)
    def __setslice__(self, *args): return _LeapPython.FloatArray___setslice__(self, *args)
    def __delslice__(self, *args): return _LeapPython.FloatArray___delslice__(self, *args)
    def __delitem__(self, *args): return _LeapPython.FloatArray___delitem__(self, *args)
    def __getitem__(self, *args): return _LeapPython.FloatArray___getitem__(self, *args)
    def __setitem__(self, *args): return _LeapPython.FloatArray___setitem__(self, *args)
    def append(self, *args): return _LeapPython.FloatArray_append(self, *args)
    def empty(self): return _LeapPython.FloatArray_empty(self)
    def size(self): return _LeapPython.FloatArray_size(self)
    def clear(self): return _LeapPython.FloatArray_clear(self)
    def swap(self, *args): return _LeapPython.FloatArray_swap(self, *args)
    def get_allocator(self): return _LeapPython.FloatArray_get_allocator(self)
    def begin(self): return _LeapPython.FloatArray_begin(self)
    def end(self): return _LeapPython.FloatArray_end(self)
    def rbegin(self): return _LeapPython.FloatArray_rbegin(self)
    def rend(self): return _LeapPython.FloatArray_rend(self)
    def pop_back(self): return _LeapPython.FloatArray_pop_back(self)
    def erase(self, *args): return _LeapPython.FloatArray_erase(self, *args)
    def __init__(self, *args): 
        this = _LeapPython.new_FloatArray(*args)
        try: self.this.append(this)
        except: self.this = this
    def push_back(self, *args): return _LeapPython.FloatArray_push_back(self, *args)
    def front(self): return _LeapPython.FloatArray_front(self)
    def back(self): return _LeapPython.FloatArray_back(self)
    def assign(self, *args): return _LeapPython.FloatArray_assign(self, *args)
    def resize(self, *args): return _LeapPython.FloatArray_resize(self, *args)
    def insert(self, *args): return _LeapPython.FloatArray_insert(self, *args)
    def reserve(self, *args): return _LeapPython.FloatArray_reserve(self, *args)
    def capacity(self): return _LeapPython.FloatArray_capacity(self)
    __swig_destroy__ = _LeapPython.delete_FloatArray
    __del__ = lambda self : None;
FloatArray_swigregister = _LeapPython.FloatArray_swigregister
FloatArray_swigregister(FloatArray)

class DoubleArray(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, DoubleArray, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, DoubleArray, name)
    __repr__ = _swig_repr
    def iterator(self): return _LeapPython.DoubleArray_iterator(self)
    def __iter__(self): return self.iterator()
    def __nonzero__(self): return _LeapPython.DoubleArray___nonzero__(self)
    def __bool__(self): return _LeapPython.DoubleArray___bool__(self)
    def __len__(self): return _LeapPython.DoubleArray___len__(self)
    def pop(self): return _LeapPython.DoubleArray_pop(self)
    def __getslice__(self, *args): return _LeapPython.DoubleArray___getslice__(self, *args)
    def __setslice__(self, *args): return _LeapPython.DoubleArray___setslice__(self, *args)
    def __delslice__(self, *args): return _LeapPython.DoubleArray___delslice__(self, *args)
    def __delitem__(self, *args): return _LeapPython.DoubleArray___delitem__(self, *args)
    def __getitem__(self, *args): return _LeapPython.DoubleArray___getitem__(self, *args)
    def __setitem__(self, *args): return _LeapPython.DoubleArray___setitem__(self, *args)
    def append(self, *args): return _LeapPython.DoubleArray_append(self, *args)
    def empty(self): return _LeapPython.DoubleArray_empty(self)
    def size(self): return _LeapPython.DoubleArray_size(self)
    def clear(self): return _LeapPython.DoubleArray_clear(self)
    def swap(self, *args): return _LeapPython.DoubleArray_swap(self, *args)
    def get_allocator(self): return _LeapPython.DoubleArray_get_allocator(self)
    def begin(self): return _LeapPython.DoubleArray_begin(self)
    def end(self): return _LeapPython.DoubleArray_end(self)
    def rbegin(self): return _LeapPython.DoubleArray_rbegin(self)
    def rend(self): return _LeapPython.DoubleArray_rend(self)
    def pop_back(self): return _LeapPython.DoubleArray_pop_back(self)
    def erase(self, *args): return _LeapPython.DoubleArray_erase(self, *args)
    def __init__(self, *args): 
        this = _LeapPython.new_DoubleArray(*args)
        try: self.this.append(this)
        except: self.this = this
    def push_back(self, *args): return _LeapPython.DoubleArray_push_back(self, *args)
    def front(self): return _LeapPython.DoubleArray_front(self)
    def back(self): return _LeapPython.DoubleArray_back(self)
    def assign(self, *args): return _LeapPython.DoubleArray_assign(self, *args)
    def resize(self, *args): return _LeapPython.DoubleArray_resize(self, *args)
    def insert(self, *args): return _LeapPython.DoubleArray_insert(self, *args)
    def reserve(self, *args): return _LeapPython.DoubleArray_reserve(self, *args)
    def capacity(self): return _LeapPython.DoubleArray_capacity(self)
    __swig_destroy__ = _LeapPython.delete_DoubleArray
    __del__ = lambda self : None;
DoubleArray_swigregister = _LeapPython.DoubleArray_swigregister
DoubleArray_swigregister(DoubleArray)

class StringArray(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, StringArray, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, StringArray, name)
    __repr__ = _swig_repr
    def iterator(self): return _LeapPython.StringArray_iterator(self)
    def __iter__(self): return self.iterator()
    def __nonzero__(self): return _LeapPython.StringArray___nonzero__(self)
    def __bool__(self): return _LeapPython.StringArray___bool__(self)
    def __len__(self): return _LeapPython.StringArray___len__(self)
    def pop(self): return _LeapPython.StringArray_pop(self)
    def __getslice__(self, *args): return _LeapPython.StringArray___getslice__(self, *args)
    def __setslice__(self, *args): return _LeapPython.StringArray___setslice__(self, *args)
    def __delslice__(self, *args): return _LeapPython.StringArray___delslice__(self, *args)
    def __delitem__(self, *args): return _LeapPython.StringArray___delitem__(self, *args)
    def __getitem__(self, *args): return _LeapPython.StringArray___getitem__(self, *args)
    def __setitem__(self, *args): return _LeapPython.StringArray___setitem__(self, *args)
    def append(self, *args): return _LeapPython.StringArray_append(self, *args)
    def empty(self): return _LeapPython.StringArray_empty(self)
    def size(self): return _LeapPython.StringArray_size(self)
    def clear(self): return _LeapPython.StringArray_clear(self)
    def swap(self, *args): return _LeapPython.StringArray_swap(self, *args)
    def get_allocator(self): return _LeapPython.StringArray_get_allocator(self)
    def begin(self): return _LeapPython.StringArray_begin(self)
    def end(self): return _LeapPython.StringArray_end(self)
    def rbegin(self): return _LeapPython.StringArray_rbegin(self)
    def rend(self): return _LeapPython.StringArray_rend(self)
    def pop_back(self): return _LeapPython.StringArray_pop_back(self)
    def erase(self, *args): return _LeapPython.StringArray_erase(self, *args)
    def __init__(self, *args): 
        this = _LeapPython.new_StringArray(*args)
        try: self.this.append(this)
        except: self.this = this
    def push_back(self, *args): return _LeapPython.StringArray_push_back(self, *args)
    def front(self): return _LeapPython.StringArray_front(self)
    def back(self): return _LeapPython.StringArray_back(self)
    def assign(self, *args): return _LeapPython.StringArray_assign(self, *args)
    def resize(self, *args): return _LeapPython.StringArray_resize(self, *args)
    def insert(self, *args): return _LeapPython.StringArray_insert(self, *args)
    def reserve(self, *args): return _LeapPython.StringArray_reserve(self, *args)
    def capacity(self): return _LeapPython.StringArray_capacity(self)
    __swig_destroy__ = _LeapPython.delete_StringArray
    __del__ = lambda self : None;
StringArray_swigregister = _LeapPython.StringArray_swigregister
StringArray_swigregister(StringArray)

class Vector(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Vector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Vector, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        this = _LeapPython.new_Vector(*args)
        try: self.this.append(this)
        except: self.this = this
    def distance_to(self, *args): return _LeapPython.Vector_distance_to(self, *args)
    def angle_to(self, *args): return _LeapPython.Vector_angle_to(self, *args)
    def dot(self, *args): return _LeapPython.Vector_dot(self, *args)
    def cross(self, *args): return _LeapPython.Vector_cross(self, *args)
    def __neg__(self): return _LeapPython.Vector___neg__(self)
    def __add__(self, *args): return _LeapPython.Vector___add__(self, *args)
    def __sub__(self, *args): return _LeapPython.Vector___sub__(self, *args)
    def __mul__(self, *args): return _LeapPython.Vector___mul__(self, *args)
    def __div__(self, *args): return _LeapPython.Vector___div__(self, *args)
    def __iadd__(self, *args): return _LeapPython.Vector___iadd__(self, *args)
    def __isub__(self, *args): return _LeapPython.Vector___isub__(self, *args)
    def __imul__(self, *args): return _LeapPython.Vector___imul__(self, *args)
    def __idiv__(self, *args): return _LeapPython.Vector___idiv__(self, *args)
    def __str__(self): return _LeapPython.Vector___str__(self)
    def __eq__(self, *args): return _LeapPython.Vector___eq__(self, *args)
    def __ne__(self, *args): return _LeapPython.Vector___ne__(self, *args)
    def is_valid(self): return _LeapPython.Vector_is_valid(self)
    def __getitem__(self, *args): return _LeapPython.Vector___getitem__(self, *args)
    __swig_setmethods__["x"] = _LeapPython.Vector_x_set
    __swig_getmethods__["x"] = _LeapPython.Vector_x_get
    if _newclass:x = _swig_property(_LeapPython.Vector_x_get, _LeapPython.Vector_x_set)
    __swig_setmethods__["y"] = _LeapPython.Vector_y_set
    __swig_getmethods__["y"] = _LeapPython.Vector_y_get
    if _newclass:y = _swig_property(_LeapPython.Vector_y_get, _LeapPython.Vector_y_set)
    __swig_setmethods__["z"] = _LeapPython.Vector_z_set
    __swig_getmethods__["z"] = _LeapPython.Vector_z_get
    if _newclass:z = _swig_property(_LeapPython.Vector_z_get, _LeapPython.Vector_z_set)
    __swig_getmethods__["magnitude"] = _LeapPython.Vector_magnitude_get
    if _newclass:magnitude = _swig_property(_LeapPython.Vector_magnitude_get)
    __swig_getmethods__["magnitude_squared"] = _LeapPython.Vector_magnitude_squared_get
    if _newclass:magnitude_squared = _swig_property(_LeapPython.Vector_magnitude_squared_get)
    __swig_getmethods__["pitch"] = _LeapPython.Vector_pitch_get
    if _newclass:pitch = _swig_property(_LeapPython.Vector_pitch_get)
    __swig_getmethods__["roll"] = _LeapPython.Vector_roll_get
    if _newclass:roll = _swig_property(_LeapPython.Vector_roll_get)
    __swig_getmethods__["yaw"] = _LeapPython.Vector_yaw_get
    if _newclass:yaw = _swig_property(_LeapPython.Vector_yaw_get)
    __swig_getmethods__["normalized"] = _LeapPython.Vector_normalized_get
    if _newclass:normalized = _swig_property(_LeapPython.Vector_normalized_get)
    def to_float_array(self): return [self.x, self.y, self.z]
    def to_tuple(self): return (self.x, self.y, self.z)

    __swig_destroy__ = _LeapPython.delete_Vector
    __del__ = lambda self : None;
Vector_swigregister = _LeapPython.Vector_swigregister
Vector_swigregister(Vector)
cvar = _LeapPython.cvar
PI = cvar.PI
DEG_TO_RAD = cvar.DEG_TO_RAD
RAD_TO_DEG = cvar.RAD_TO_DEG
Vector.zero = _LeapPython.cvar.Vector_zero
Vector.x_axis = _LeapPython.cvar.Vector_x_axis
Vector.y_axis = _LeapPython.cvar.Vector_y_axis
Vector.z_axis = _LeapPython.cvar.Vector_z_axis
Vector.forward = _LeapPython.cvar.Vector_forward
Vector.backward = _LeapPython.cvar.Vector_backward
Vector.left = _LeapPython.cvar.Vector_left
Vector.right = _LeapPython.cvar.Vector_right
Vector.up = _LeapPython.cvar.Vector_up
Vector.down = _LeapPython.cvar.Vector_down

class Matrix(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Matrix, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Matrix, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        this = _LeapPython.new_Matrix(*args)
        try: self.this.append(this)
        except: self.this = this
    def set_rotation(self, *args): return _LeapPython.Matrix_set_rotation(self, *args)
    def transform_point(self, *args): return _LeapPython.Matrix_transform_point(self, *args)
    def transform_direction(self, *args): return _LeapPython.Matrix_transform_direction(self, *args)
    def rigid_inverse(self): return _LeapPython.Matrix_rigid_inverse(self)
    def __mul__(self, *args): return _LeapPython.Matrix___mul__(self, *args)
    def __imul__(self, *args): return _LeapPython.Matrix___imul__(self, *args)
    def __eq__(self, *args): return _LeapPython.Matrix___eq__(self, *args)
    def __ne__(self, *args): return _LeapPython.Matrix___ne__(self, *args)
    def __str__(self): return _LeapPython.Matrix___str__(self)
    __swig_setmethods__["x_basis"] = _LeapPython.Matrix_x_basis_set
    __swig_getmethods__["x_basis"] = _LeapPython.Matrix_x_basis_get
    if _newclass:x_basis = _swig_property(_LeapPython.Matrix_x_basis_get, _LeapPython.Matrix_x_basis_set)
    __swig_setmethods__["y_basis"] = _LeapPython.Matrix_y_basis_set
    __swig_getmethods__["y_basis"] = _LeapPython.Matrix_y_basis_get
    if _newclass:y_basis = _swig_property(_LeapPython.Matrix_y_basis_get, _LeapPython.Matrix_y_basis_set)
    __swig_setmethods__["z_basis"] = _LeapPython.Matrix_z_basis_set
    __swig_getmethods__["z_basis"] = _LeapPython.Matrix_z_basis_get
    if _newclass:z_basis = _swig_property(_LeapPython.Matrix_z_basis_get, _LeapPython.Matrix_z_basis_set)
    __swig_setmethods__["origin"] = _LeapPython.Matrix_origin_set
    __swig_getmethods__["origin"] = _LeapPython.Matrix_origin_get
    if _newclass:origin = _swig_property(_LeapPython.Matrix_origin_get, _LeapPython.Matrix_origin_set)
    def to_array_3x3(self, output = None):
        if output is None:
            output = [0]*9
        output[0], output[1], output[2] = self.x_basis.x, self.x_basis.y, self.x_basis.z
        output[3], output[4], output[5] = self.y_basis.x, self.y_basis.y, self.y_basis.z
        output[6], output[7], output[8] = self.z_basis.x, self.z_basis.y, self.z_basis.z
        return output
    def to_array_4x4(self, output = None):
        if output is None:
            output = [0]*16
        output[0],  output[1],  output[2],  output[3]  = self.x_basis.x, self.x_basis.y, self.x_basis.z, 0.0
        output[4],  output[5],  output[6],  output[7]  = self.y_basis.x, self.y_basis.y, self.y_basis.z, 0.0
        output[8],  output[9],  output[10], output[11] = self.z_basis.x, self.z_basis.y, self.z_basis.z, 0.0
        output[12], output[13], output[14], output[15] = self.origin.x,  self.origin.y,  self.origin.z,  1.0
        return output

    __swig_destroy__ = _LeapPython.delete_Matrix
    __del__ = lambda self : None;
Matrix_swigregister = _LeapPython.Matrix_swigregister
Matrix_swigregister(Matrix)
Matrix.identity = _LeapPython.cvar.Matrix_identity

class Interface(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Interface, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Interface, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
Interface_swigregister = _LeapPython.Interface_swigregister
Interface_swigregister(Interface)

class Pointable(Interface):
    __swig_setmethods__ = {}
    for _s in [Interface]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Pointable, name, value)
    __swig_getmethods__ = {}
    for _s in [Interface]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, Pointable, name)
    __repr__ = _swig_repr
    def __init__(self): 
        this = _LeapPython.new_Pointable()
        try: self.this.append(this)
        except: self.this = this
    def __eq__(self, *args): return _LeapPython.Pointable___eq__(self, *args)
    def __ne__(self, *args): return _LeapPython.Pointable___ne__(self, *args)
    def __str__(self): return _LeapPython.Pointable___str__(self)
    __swig_getmethods__["id"] = _LeapPython.Pointable_id_get
    if _newclass:id = _swig_property(_LeapPython.Pointable_id_get)
    __swig_getmethods__["hand"] = _LeapPython.Pointable_hand_get
    if _newclass:hand = _swig_property(_LeapPython.Pointable_hand_get)
    __swig_getmethods__["tip_position"] = _LeapPython.Pointable_tip_position_get
    if _newclass:tip_position = _swig_property(_LeapPython.Pointable_tip_position_get)
    __swig_getmethods__["tip_velocity"] = _LeapPython.Pointable_tip_velocity_get
    if _newclass:tip_velocity = _swig_property(_LeapPython.Pointable_tip_velocity_get)
    __swig_getmethods__["direction"] = _LeapPython.Pointable_direction_get
    if _newclass:direction = _swig_property(_LeapPython.Pointable_direction_get)
    __swig_getmethods__["width"] = _LeapPython.Pointable_width_get
    if _newclass:width = _swig_property(_LeapPython.Pointable_width_get)
    __swig_getmethods__["length"] = _LeapPython.Pointable_length_get
    if _newclass:length = _swig_property(_LeapPython.Pointable_length_get)
    __swig_getmethods__["is_tool"] = _LeapPython.Pointable_is_tool_get
    if _newclass:is_tool = _swig_property(_LeapPython.Pointable_is_tool_get)
    __swig_getmethods__["is_finger"] = _LeapPython.Pointable_is_finger_get
    if _newclass:is_finger = _swig_property(_LeapPython.Pointable_is_finger_get)
    __swig_getmethods__["is_valid"] = _LeapPython.Pointable_is_valid_get
    if _newclass:is_valid = _swig_property(_LeapPython.Pointable_is_valid_get)
    __swig_getmethods__["frame"] = _LeapPython.Pointable_frame_get
    if _newclass:frame = _swig_property(_LeapPython.Pointable_frame_get)
    __swig_destroy__ = _LeapPython.delete_Pointable
    __del__ = lambda self : None;
Pointable_swigregister = _LeapPython.Pointable_swigregister
Pointable_swigregister(Pointable)
Pointable.invalid = _LeapPython.cvar.Pointable_invalid

class Finger(Pointable):
    __swig_setmethods__ = {}
    for _s in [Pointable]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Finger, name, value)
    __swig_getmethods__ = {}
    for _s in [Pointable]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, Finger, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        this = _LeapPython.new_Finger(*args)
        try: self.this.append(this)
        except: self.this = this
    def __str__(self): return _LeapPython.Finger___str__(self)
    __swig_destroy__ = _LeapPython.delete_Finger
    __del__ = lambda self : None;
Finger_swigregister = _LeapPython.Finger_swigregister
Finger_swigregister(Finger)
Finger.invalid = _LeapPython.cvar.Finger_invalid

class Tool(Pointable):
    __swig_setmethods__ = {}
    for _s in [Pointable]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Tool, name, value)
    __swig_getmethods__ = {}
    for _s in [Pointable]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, Tool, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        this = _LeapPython.new_Tool(*args)
        try: self.this.append(this)
        except: self.this = this
    def __str__(self): return _LeapPython.Tool___str__(self)
    __swig_destroy__ = _LeapPython.delete_Tool
    __del__ = lambda self : None;
Tool_swigregister = _LeapPython.Tool_swigregister
Tool_swigregister(Tool)
Tool.invalid = _LeapPython.cvar.Tool_invalid

class Hand(Interface):
    __swig_setmethods__ = {}
    for _s in [Interface]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Hand, name, value)
    __swig_getmethods__ = {}
    for _s in [Interface]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, Hand, name)
    __repr__ = _swig_repr
    def __init__(self): 
        this = _LeapPython.new_Hand()
        try: self.this.append(this)
        except: self.this = this
    def pointable(self, *args): return _LeapPython.Hand_pointable(self, *args)
    def finger(self, *args): return _LeapPython.Hand_finger(self, *args)
    def tool(self, *args): return _LeapPython.Hand_tool(self, *args)
    def translation(self, *args): return _LeapPython.Hand_translation(self, *args)
    def rotation_axis(self, *args): return _LeapPython.Hand_rotation_axis(self, *args)
    def rotation_angle(self, *args): return _LeapPython.Hand_rotation_angle(self, *args)
    def rotation_matrix(self, *args): return _LeapPython.Hand_rotation_matrix(self, *args)
    def scale_factor(self, *args): return _LeapPython.Hand_scale_factor(self, *args)
    def __eq__(self, *args): return _LeapPython.Hand___eq__(self, *args)
    def __ne__(self, *args): return _LeapPython.Hand___ne__(self, *args)
    def __str__(self): return _LeapPython.Hand___str__(self)
    __swig_getmethods__["id"] = _LeapPython.Hand_id_get
    if _newclass:id = _swig_property(_LeapPython.Hand_id_get)
    __swig_getmethods__["pointables"] = _LeapPython.Hand_pointables_get
    if _newclass:pointables = _swig_property(_LeapPython.Hand_pointables_get)
    __swig_getmethods__["fingers"] = _LeapPython.Hand_fingers_get
    if _newclass:fingers = _swig_property(_LeapPython.Hand_fingers_get)
    __swig_getmethods__["tools"] = _LeapPython.Hand_tools_get
    if _newclass:tools = _swig_property(_LeapPython.Hand_tools_get)
    __swig_getmethods__["palm_position"] = _LeapPython.Hand_palm_position_get
    if _newclass:palm_position = _swig_property(_LeapPython.Hand_palm_position_get)
    __swig_getmethods__["palm_velocity"] = _LeapPython.Hand_palm_velocity_get
    if _newclass:palm_velocity = _swig_property(_LeapPython.Hand_palm_velocity_get)
    __swig_getmethods__["palm_normal"] = _LeapPython.Hand_palm_normal_get
    if _newclass:palm_normal = _swig_property(_LeapPython.Hand_palm_normal_get)
    __swig_getmethods__["direction"] = _LeapPython.Hand_direction_get
    if _newclass:direction = _swig_property(_LeapPython.Hand_direction_get)
    __swig_getmethods__["is_valid"] = _LeapPython.Hand_is_valid_get
    if _newclass:is_valid = _swig_property(_LeapPython.Hand_is_valid_get)
    __swig_getmethods__["sphere_center"] = _LeapPython.Hand_sphere_center_get
    if _newclass:sphere_center = _swig_property(_LeapPython.Hand_sphere_center_get)
    __swig_getmethods__["sphere_radius"] = _LeapPython.Hand_sphere_radius_get
    if _newclass:sphere_radius = _swig_property(_LeapPython.Hand_sphere_radius_get)
    __swig_getmethods__["frame"] = _LeapPython.Hand_frame_get
    if _newclass:frame = _swig_property(_LeapPython.Hand_frame_get)
    __swig_destroy__ = _LeapPython.delete_Hand
    __del__ = lambda self : None;
Hand_swigregister = _LeapPython.Hand_swigregister
Hand_swigregister(Hand)
Hand.invalid = _LeapPython.cvar.Hand_invalid

class PointableList(Interface):
    __swig_setmethods__ = {}
    for _s in [Interface]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, PointableList, name, value)
    __swig_getmethods__ = {}
    for _s in [Interface]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, PointableList, name)
    __repr__ = _swig_repr
    def __init__(self): 
        this = _LeapPython.new_PointableList()
        try: self.this.append(this)
        except: self.this = this
    def __len__(self): return _LeapPython.PointableList___len__(self)
    def __getitem__(self, *args): return _LeapPython.PointableList___getitem__(self, *args)
    def append(self, *args): return _LeapPython.PointableList_append(self, *args)
    __swig_getmethods__["empty"] = _LeapPython.PointableList_empty_get
    if _newclass:empty = _swig_property(_LeapPython.PointableList_empty_get)
    def __iter__(self):
      _pos = 0
      while _pos < len(self):
        yield self[_pos]
        _pos += 1

    __swig_destroy__ = _LeapPython.delete_PointableList
    __del__ = lambda self : None;
PointableList_swigregister = _LeapPython.PointableList_swigregister
PointableList_swigregister(PointableList)

class FingerList(Interface):
    __swig_setmethods__ = {}
    for _s in [Interface]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, FingerList, name, value)
    __swig_getmethods__ = {}
    for _s in [Interface]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, FingerList, name)
    __repr__ = _swig_repr
    def __init__(self): 
        this = _LeapPython.new_FingerList()
        try: self.this.append(this)
        except: self.this = this
    def __len__(self): return _LeapPython.FingerList___len__(self)
    def __getitem__(self, *args): return _LeapPython.FingerList___getitem__(self, *args)
    def append(self, *args): return _LeapPython.FingerList_append(self, *args)
    __swig_getmethods__["empty"] = _LeapPython.FingerList_empty_get
    if _newclass:empty = _swig_property(_LeapPython.FingerList_empty_get)
    def __iter__(self):
      _pos = 0
      while _pos < len(self):
        yield self[_pos]
        _pos += 1

    __swig_destroy__ = _LeapPython.delete_FingerList
    __del__ = lambda self : None;
FingerList_swigregister = _LeapPython.FingerList_swigregister
FingerList_swigregister(FingerList)

class ToolList(Interface):
    __swig_setmethods__ = {}
    for _s in [Interface]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ToolList, name, value)
    __swig_getmethods__ = {}
    for _s in [Interface]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, ToolList, name)
    __repr__ = _swig_repr
    def __init__(self): 
        this = _LeapPython.new_ToolList()
        try: self.this.append(this)
        except: self.this = this
    def __len__(self): return _LeapPython.ToolList___len__(self)
    def __getitem__(self, *args): return _LeapPython.ToolList___getitem__(self, *args)
    def append(self, *args): return _LeapPython.ToolList_append(self, *args)
    __swig_getmethods__["empty"] = _LeapPython.ToolList_empty_get
    if _newclass:empty = _swig_property(_LeapPython.ToolList_empty_get)
    def __iter__(self):
      _pos = 0
      while _pos < len(self):
        yield self[_pos]
        _pos += 1

    __swig_destroy__ = _LeapPython.delete_ToolList
    __del__ = lambda self : None;
ToolList_swigregister = _LeapPython.ToolList_swigregister
ToolList_swigregister(ToolList)

class HandList(Interface):
    __swig_setmethods__ = {}
    for _s in [Interface]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, HandList, name, value)
    __swig_getmethods__ = {}
    for _s in [Interface]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, HandList, name)
    __repr__ = _swig_repr
    def __init__(self): 
        this = _LeapPython.new_HandList()
        try: self.this.append(this)
        except: self.this = this
    def __len__(self): return _LeapPython.HandList___len__(self)
    def __getitem__(self, *args): return _LeapPython.HandList___getitem__(self, *args)
    def append(self, *args): return _LeapPython.HandList_append(self, *args)
    __swig_getmethods__["empty"] = _LeapPython.HandList_empty_get
    if _newclass:empty = _swig_property(_LeapPython.HandList_empty_get)
    def __iter__(self):
      _pos = 0
      while _pos < len(self):
        yield self[_pos]
        _pos += 1

    __swig_destroy__ = _LeapPython.delete_HandList
    __del__ = lambda self : None;
HandList_swigregister = _LeapPython.HandList_swigregister
HandList_swigregister(HandList)

class ScreenList(Interface):
    __swig_setmethods__ = {}
    for _s in [Interface]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ScreenList, name, value)
    __swig_getmethods__ = {}
    for _s in [Interface]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, ScreenList, name)
    __repr__ = _swig_repr
    def __init__(self): 
        this = _LeapPython.new_ScreenList()
        try: self.this.append(this)
        except: self.this = this
    def __len__(self): return _LeapPython.ScreenList___len__(self)
    def __getitem__(self, *args): return _LeapPython.ScreenList___getitem__(self, *args)
    def closest_screen_hit(self, *args): return _LeapPython.ScreenList_closest_screen_hit(self, *args)
    __swig_getmethods__["empty"] = _LeapPython.ScreenList_empty_get
    if _newclass:empty = _swig_property(_LeapPython.ScreenList_empty_get)
    def __iter__(self):
      _pos = 0
      while _pos < len(self):
        yield self[_pos]
        _pos += 1

    __swig_destroy__ = _LeapPython.delete_ScreenList
    __del__ = lambda self : None;
ScreenList_swigregister = _LeapPython.ScreenList_swigregister
ScreenList_swigregister(ScreenList)

class Screen(Interface):
    __swig_setmethods__ = {}
    for _s in [Interface]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Screen, name, value)
    __swig_getmethods__ = {}
    for _s in [Interface]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, Screen, name)
    __repr__ = _swig_repr
    def __init__(self): 
        this = _LeapPython.new_Screen()
        try: self.this.append(this)
        except: self.this = this
    def intersect(self, *args): return _LeapPython.Screen_intersect(self, *args)
    def normal(self): return _LeapPython.Screen_normal(self)
    def distance_to_point(self, *args): return _LeapPython.Screen_distance_to_point(self, *args)
    def __eq__(self, *args): return _LeapPython.Screen___eq__(self, *args)
    def __ne__(self, *args): return _LeapPython.Screen___ne__(self, *args)
    def __str__(self): return _LeapPython.Screen___str__(self)
    __swig_getmethods__["id"] = _LeapPython.Screen_id_get
    if _newclass:id = _swig_property(_LeapPython.Screen_id_get)
    __swig_getmethods__["horizontal_axis"] = _LeapPython.Screen_horizontal_axis_get
    if _newclass:horizontal_axis = _swig_property(_LeapPython.Screen_horizontal_axis_get)
    __swig_getmethods__["vertical_axis"] = _LeapPython.Screen_vertical_axis_get
    if _newclass:vertical_axis = _swig_property(_LeapPython.Screen_vertical_axis_get)
    __swig_getmethods__["bottom_left_corner"] = _LeapPython.Screen_bottom_left_corner_get
    if _newclass:bottom_left_corner = _swig_property(_LeapPython.Screen_bottom_left_corner_get)
    __swig_getmethods__["width_pixels"] = _LeapPython.Screen_width_pixels_get
    if _newclass:width_pixels = _swig_property(_LeapPython.Screen_width_pixels_get)
    __swig_getmethods__["height_pixels"] = _LeapPython.Screen_height_pixels_get
    if _newclass:height_pixels = _swig_property(_LeapPython.Screen_height_pixels_get)
    __swig_getmethods__["is_valid"] = _LeapPython.Screen_is_valid_get
    if _newclass:is_valid = _swig_property(_LeapPython.Screen_is_valid_get)
    __swig_destroy__ = _LeapPython.delete_Screen
    __del__ = lambda self : None;
Screen_swigregister = _LeapPython.Screen_swigregister
Screen_swigregister(Screen)
Screen.invalid = _LeapPython.cvar.Screen_invalid

class Frame(Interface):
    __swig_setmethods__ = {}
    for _s in [Interface]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Frame, name, value)
    __swig_getmethods__ = {}
    for _s in [Interface]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, Frame, name)
    __repr__ = _swig_repr
    def __init__(self): 
        this = _LeapPython.new_Frame()
        try: self.this.append(this)
        except: self.this = this
    def hand(self, *args): return _LeapPython.Frame_hand(self, *args)
    def pointable(self, *args): return _LeapPython.Frame_pointable(self, *args)
    def finger(self, *args): return _LeapPython.Frame_finger(self, *args)
    def tool(self, *args): return _LeapPython.Frame_tool(self, *args)
    def translation(self, *args): return _LeapPython.Frame_translation(self, *args)
    def rotation_axis(self, *args): return _LeapPython.Frame_rotation_axis(self, *args)
    def rotation_angle(self, *args): return _LeapPython.Frame_rotation_angle(self, *args)
    def rotation_matrix(self, *args): return _LeapPython.Frame_rotation_matrix(self, *args)
    def scale_factor(self, *args): return _LeapPython.Frame_scale_factor(self, *args)
    def __eq__(self, *args): return _LeapPython.Frame___eq__(self, *args)
    def __ne__(self, *args): return _LeapPython.Frame___ne__(self, *args)
    def __str__(self): return _LeapPython.Frame___str__(self)
    __swig_getmethods__["id"] = _LeapPython.Frame_id_get
    if _newclass:id = _swig_property(_LeapPython.Frame_id_get)
    __swig_getmethods__["timestamp"] = _LeapPython.Frame_timestamp_get
    if _newclass:timestamp = _swig_property(_LeapPython.Frame_timestamp_get)
    __swig_getmethods__["hands"] = _LeapPython.Frame_hands_get
    if _newclass:hands = _swig_property(_LeapPython.Frame_hands_get)
    __swig_getmethods__["pointables"] = _LeapPython.Frame_pointables_get
    if _newclass:pointables = _swig_property(_LeapPython.Frame_pointables_get)
    __swig_getmethods__["fingers"] = _LeapPython.Frame_fingers_get
    if _newclass:fingers = _swig_property(_LeapPython.Frame_fingers_get)
    __swig_getmethods__["tools"] = _LeapPython.Frame_tools_get
    if _newclass:tools = _swig_property(_LeapPython.Frame_tools_get)
    __swig_getmethods__["is_valid"] = _LeapPython.Frame_is_valid_get
    if _newclass:is_valid = _swig_property(_LeapPython.Frame_is_valid_get)
    __swig_destroy__ = _LeapPython.delete_Frame
    __del__ = lambda self : None;
Frame_swigregister = _LeapPython.Frame_swigregister
Frame_swigregister(Frame)
Frame.invalid = _LeapPython.cvar.Frame_invalid

class Config(Interface):
    __swig_setmethods__ = {}
    for _s in [Interface]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Config, name, value)
    __swig_getmethods__ = {}
    for _s in [Interface]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, Config, name)
    __repr__ = _swig_repr
    def __init__(self): 
        this = _LeapPython.new_Config()
        try: self.this.append(this)
        except: self.this = this
    TYPE_UNKNOWN = _LeapPython.Config_TYPE_UNKNOWN
    TYPE_BOOLEAN = _LeapPython.Config_TYPE_BOOLEAN
    TYPE_INT32 = _LeapPython.Config_TYPE_INT32
    TYPE_INT64 = _LeapPython.Config_TYPE_INT64
    TYPE_UINT32 = _LeapPython.Config_TYPE_UINT32
    TYPE_UINT64 = _LeapPython.Config_TYPE_UINT64
    TYPE_FLOAT = _LeapPython.Config_TYPE_FLOAT
    TYPE_DOUBLE = _LeapPython.Config_TYPE_DOUBLE
    TYPE_STRING = _LeapPython.Config_TYPE_STRING
















    def get(self, *args):
      type = _LeapPython.Config_type(self, *args)
      if _LeapPython.Config_is_array(self, *args):
        if type == _LeapPython.Config_TYPE_BOOLEAN:
          return _LeapPython.Config_get_bool_array(self, *args)
        elif type == _LeapPython.Config_TYPE_INT32:
          return _LeapPython.Config_get_int_32array(self, *args)
        elif type == _LeapPython.Config_TYPE_INT64:
          return _LeapPython.Config_get_int_32array(self, *args)
        elif type == _LeapPython.Config_TYPE_UINT32:
          return _LeapPython.Config_get_uint_32array(self, *args)
        elif type == _LeapPython.Config_TYPE_UINT64:
          return _LeapPython.Config_get_uint_32array(self, *args)
        elif type == _LeapPython.Config_TYPE_FLOAT:
          return _LeapPython.Config_get_float_array(self, *args)
        elif type == _LeapPython.Config_TYPE_DOUBLE:
          return _LeapPython.Config_get_double_array(self, *args)
        elif type == _LeapPython.Config_TYPE_STRING:
          return _LeapPython.Config_get_string_array(self, *args)
      else:
        if type == _LeapPython.Config_TYPE_BOOLEAN:
          return _LeapPython.Config_get_bool(self, *args)
        elif type == _LeapPython.Config_TYPE_INT32:
          return _LeapPython.Config_get_int_32(self, *args)
        elif type == _LeapPython.Config_TYPE_INT64:
          return _LeapPython.Config_get_int_64(self, *args)
        elif type == _LeapPython.Config_TYPE_UINT32:
          return _LeapPython.Config_get_uint_32(self, *args)
        elif type == _LeapPython.Config_TYPE_UINT64:
          return _LeapPython.Config_get_uint_64(self, *args)
        elif type == _LeapPython.Config_TYPE_FLOAT:
          return _LeapPython.Config_get_float(self, *args)
        elif type == _LeapPython.Config_TYPE_DOUBLE:
          return _LeapPython.Config_get_double(self, *args)
        elif type == _LeapPython.Config_TYPE_STRING:
          return _LeapPython.Config_get_string(self, *args)
      return None

    __swig_destroy__ = _LeapPython.delete_Config
    __del__ = lambda self : None;
Config_swigregister = _LeapPython.Config_swigregister
Config_swigregister(Config)

class Controller(Interface):
    __swig_setmethods__ = {}
    for _s in [Interface]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Controller, name, value)
    __swig_getmethods__ = {}
    for _s in [Interface]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, Controller, name)
    __repr__ = _swig_repr
    __swig_destroy__ = _LeapPython.delete_Controller
    __del__ = lambda self : None;
    def __init__(self, *args): 
        this = _LeapPython.new_Controller(*args)
        try: self.this.append(this)
        except: self.this = this
    def add_listener(self, *args): return _LeapPython.Controller_add_listener(self, *args)
    def remove_listener(self, *args): return _LeapPython.Controller_remove_listener(self, *args)
    def frame(self, history=0): return _LeapPython.Controller_frame(self, history)
    __swig_getmethods__["is_connected"] = _LeapPython.Controller_is_connected_get
    if _newclass:is_connected = _swig_property(_LeapPython.Controller_is_connected_get)
    __swig_getmethods__["config"] = _LeapPython.Controller_config_get
    if _newclass:config = _swig_property(_LeapPython.Controller_config_get)
    __swig_getmethods__["calibrated_screens"] = _LeapPython.Controller_calibrated_screens_get
    if _newclass:calibrated_screens = _swig_property(_LeapPython.Controller_calibrated_screens_get)
Controller_swigregister = _LeapPython.Controller_swigregister
Controller_swigregister(Controller)

class Listener(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Listener, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Listener, name)
    __repr__ = _swig_repr
    def __init__(self): 
        if self.__class__ == Listener:
            _self = None
        else:
            _self = self
        this = _LeapPython.new_Listener(_self, )
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _LeapPython.delete_Listener
    __del__ = lambda self : None;
    def on_init(self, *args): return _LeapPython.Listener_on_init(self, *args)
    def on_connect(self, *args): return _LeapPython.Listener_on_connect(self, *args)
    def on_disconnect(self, *args): return _LeapPython.Listener_on_disconnect(self, *args)
    def on_exit(self, *args): return _LeapPython.Listener_on_exit(self, *args)
    def on_frame(self, *args): return _LeapPython.Listener_on_frame(self, *args)
    def __disown__(self):
        self.this.disown()
        _LeapPython.disown_Listener(self)
        return weakref_proxy(self)
Listener_swigregister = _LeapPython.Listener_swigregister
Listener_swigregister(Listener)

# This file is compatible with both classic and new-style classes.


